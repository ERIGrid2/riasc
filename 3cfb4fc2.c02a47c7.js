(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{112:function(e,t,n){"use strict";n.d(t,"a",(function(){return p})),n.d(t,"b",(function(){return u}));var r=n(0),i=n.n(r);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function c(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,i=function(e,t){if(null==e)return{};var n,r,i={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=i.a.createContext({}),b=function(e){var t=i.a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):c(c({},t),e)),n},p=function(e){var t=b(e.components);return i.a.createElement(s.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return i.a.createElement(i.a.Fragment,{},t)}},m=i.a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,a=e.originalType,o=e.parentName,s=l(e,["components","mdxType","originalType","parentName"]),p=b(n),m=r,u=p["".concat(o,".").concat(m)]||p[m]||d[m]||a;return n?i.a.createElement(u,c(c({ref:t},s),{},{components:n})):i.a.createElement(u,c({ref:t},s))}));function u(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var a=n.length,o=new Array(a);o[0]=m;var c={};for(var l in t)hasOwnProperty.call(t,l)&&(c[l]=t[l]);c.originalType=e,c.mdxType="string"==typeof e?e:r,o[1]=c;for(var s=2;s<a;s++)o[s]=n[s];return i.a.createElement.apply(null,o)}return i.a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},81:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return o})),n.d(t,"metadata",(function(){return c})),n.d(t,"toc",(function(){return l})),n.d(t,"default",(function(){return b}));var r=n(3),i=n(7),a=(n(0),n(112)),o={id:"time-sync",title:"Time Synchronization",sidebar_label:"Time Synchronization",slug:"/design/time-sync",partners:["uos","rwth"]},c={unversionedId:"design/time-sync",id:"design/time-sync",isDocsHomePage:!1,title:"Time Synchronization",description:"Facts",source:"@site/docs/design/time-sync.md",slug:"/design/time-sync",permalink:"/docs/design/time-sync",editUrl:"https://github.com/ERIGrid2/riasc/edit/master/docs/design/time-sync.md",version:"current",sidebar_label:"Time Synchronization",sidebar:"docs",previous:{title:"IP-Gateway/NAT for cluster-external devices",permalink:"/docs/design/ip-gateway"},next:{title:"Network emulation (netem) CNI-plugin for Kubernetes",permalink:"/docs/design/network-emulation"}},l=[{value:"Daemonset",id:"daemonset",children:[]},{value:"Linux kernel-level PPS device",id:"linux-kernel-level-pps-device",children:[]},{value:"Status reporting",id:"status-reporting",children:[]},{value:"Synchronization sources",id:"synchronization-sources",children:[]}],s={toc:l};function b(e){var t=e.components,n=Object(i.a)(e,["components"]);return Object(a.b)("wrapper",Object(r.a)({},s,n,{components:t,mdxType:"MDXLayout"}),Object(a.b)("h1",{id:"facts"},"Facts"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},Object(a.b)("strong",{parentName:"li"},"Git Repo:")," ",Object(a.b)("a",{parentName:"li",href:"https://github.com/ERIGrid2/charts/tree/master/charts/riasc/templates/time-sync"},"https://github.com/ERIGrid2/charts/tree/master/charts/riasc/templates/time-sync")),Object(a.b)("li",{parentName:"ul"},Object(a.b)("strong",{parentName:"li"},"State:")," under development")),Object(a.b)("h1",{id:"introduction"},"Introduction"),Object(a.b)("p",null,"This guide describes the steps to setup time-synchronization for embbeded single-board computers (SBCs) such as a Raspberry Pi.\nThe time-synchronization relies on a comodity GPS module providing a pulse-per-second (PPS) output to a GPIO pin of the SBC."),Object(a.b)("h1",{id:"employed-technologies"},"Employed technologies"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",{parentName:"li",href:"https://chrony.tuxfamily.org/"},"Chrony")),Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",{parentName:"li",href:"https://www.berlios.de/software/gpsd/"},"GPSd")),Object(a.b)("li",{parentName:"ul"},"Kubernetes Node-status")),Object(a.b)("h1",{id:"applications"},"Applications"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"Time-delay compensation"),Object(a.b)("li",{parentName:"ul"},"Logging/timestamping/tracing of interface signals"),Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",{parentName:"li",href:"/docs/design/network-monitoring"},"Network monitoring"))),Object(a.b)("h1",{id:"functional-requirements"},"Functional Requirements"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"Microsecond accuracy"),Object(a.b)("li",{parentName:"ul"},"Auto-configuration of sychronization source"),Object(a.b)("li",{parentName:"ul"},"Support for multiple synchronization sources"),Object(a.b)("li",{parentName:"ul"},"Reporting of sychronization status")),Object(a.b)("h1",{id:"architecture"},"Architecture"),Object(a.b)("h2",{id:"daemonset"},"Daemonset"),Object(a.b)("p",null,"Time-synchronization is implemented by a cluster-wide ",Object(a.b)("em",{parentName:"p"},"Daemonset")," which spawns a single ",Object(a.b)("em",{parentName:"p"},"Pod")," on each cluster node.\nThese ",Object(a.b)("em",{parentName:"p"},"Pods")," execute three containers:"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"chronyd")),Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"chronyd-monitor")),Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"gpsd"))),Object(a.b)("p",null,"All containers in the ",Object(a.b)("em",{parentName:"p"},"Pod")," communicate via sockets which are placed into a shared emptyDir volume.\nThere are three sockets created:"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"gpsd")," -> ",Object(a.b)("inlineCode",{parentName:"li"},"chronyd")," coarse date-time: ",Object(a.b)("inlineCode",{parentName:"li"},"/run/chrony.ttyAMA0.sock")),Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"gpsd")," -> ",Object(a.b)("inlineCode",{parentName:"li"},"chronyd")," precise PPS timing: ",Object(a.b)("inlineCode",{parentName:"li"},"/run/chrony.pps0.sock")),Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"chronyd-monitor")," -> ",Object(a.b)("inlineCode",{parentName:"li"},"chronyd")," status reporting: ",Object(a.b)("inlineCode",{parentName:"li"},"/run/chrony"))),Object(a.b)("p",null,"All sockets are created by chronyd and subsequentially opened by gpsd and the chronyd-monitor script.\nThe first two sockets are used to provide rough date-time as well as PPS timing information from gpsd to chronyd.\nThe last socket is usually used by the chronyc command line tool to interact with the chronyd daemon.\nHere the socket is also used by the chronyd-monitor script to periodically check the sync status and publish it to the Kubernetes api-server."),Object(a.b)("p",null,"In addition to the shared sockets, some physical devices are mounted from the host into the containers using a hostPath volume.\nThe gpsd container gets both the serial device ",Object(a.b)("inlineCode",{parentName:"p"},"/dev/ttyAMA0")," as well as the ",Object(a.b)("inlineCode",{parentName:"p"},"/dev/pps0")," device mounted.\nThe chronyd container only gets the PPS device ",Object(a.b)("inlineCode",{parentName:"p"},"/dev/pps0")," mounted."),Object(a.b)("h2",{id:"linux-kernel-level-pps-device"},"Linux kernel-level PPS device"),Object(a.b)("p",null,"Both gpsd and chronyd use the kernel-based PPS device order for the PPS ",Object(a.b)("inlineCode",{parentName:"p"},"/dev/pps0")," device to be created a special devicetree overlay needs to be loaded during boot-up."),Object(a.b)("h2",{id:"status-reporting"},"Status reporting"),Object(a.b)("p",null,"As mentioned above a dedicated ",Object(a.b)("inlineCode",{parentName:"p"},"chronyd-monitor")," container in the time-sync ",Object(a.b)("em",{parentName:"p"},"Pods")," is used to periodically publish the current synchronization state from chronyd in the form of a ",Object(a.b)("em",{parentName:"p"},"Node status-condition")," to the Kubernetes api-server."),Object(a.b)("p",null,"This container runs a ",Object(a.b)("a",{parentName:"p",href:"https://github.com/ERIGrid2/charts/blob/master/images/time-sync/chrony-monitor.py"},"Python script")," which periodically calls"),Object(a.b)("h2",{id:"synchronization-sources"},"Synchronization sources"),Object(a.b)("p",null,"In order of their priority:"),Object(a.b)("ol",null,Object(a.b)("li",{parentName:"ol"},Object(a.b)("a",{parentName:"li",href:"https://en.wikipedia.org/wiki/Pulse-per-second_signal"},"Pulse-per-second signal (PPS)"),Object(a.b)("ol",{parentName:"li"},Object(a.b)("li",{parentName:"ol"},"Kernel-based PPS (kPPS)"),Object(a.b)("li",{parentName:"ol"},"Userspace PPS"))),Object(a.b)("li",{parentName:"ol"},Object(a.b)("a",{parentName:"li",href:"https://en.wikipedia.org/wiki/Precision_Time_Protocol"},"Precision Time Protocol (PTP)")),Object(a.b)("li",{parentName:"ol"},Object(a.b)("a",{parentName:"li",href:"https://en.wikipedia.org/wiki/Network_Time_Protocol"},"Network Time Protocol (NTP)")),Object(a.b)("li",{parentName:"ol"},Object(a.b)("a",{parentName:"li",href:"https://en.wikipedia.org/wiki/Real-time_clock"},"Real-time Clock (RTC)"))),Object(a.b)("h1",{id:"testing"},"Testing"),Object(a.b)("ol",null,Object(a.b)("li",{parentName:"ol"},Object(a.b)("p",{parentName:"li"},"Local testing"),Object(a.b)("ul",{parentName:"li"},Object(a.b)("li",{parentName:"ul"},"Two Raspberry Pis"),Object(a.b)("li",{parentName:"ul"},"Independent synchronization sources"),Object(a.b)("li",{parentName:"ul"},"Equal or different synchronization types"),Object(a.b)("li",{parentName:"ul"},"Produce periodic rising edge via GPIO"),Object(a.b)("li",{parentName:"ul"},"Use oscilloscope to measure time offset between edges"))),Object(a.b)("li",{parentName:"ol"},Object(a.b)("p",{parentName:"li"},"Reporting synchronization status between RIs"),Object(a.b)("ul",{parentName:"li"},Object(a.b)("li",{parentName:"ul"},"Retrieve sync status from Chrony")))),Object(a.b)("h1",{id:"further-reading"},"Further Reading"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",{parentName:"li",href:"https://chrony.tuxfamily.org/documentation.html"},"Chrony Documentationd")),Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",{parentName:"li",href:"https://gpsd.gitlab.io/gpsd/gpsd-time-service-howto.html#_feeding_chrony_from_gpsd"},"GPSD Time Service HOWTO")),Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",{parentName:"li",href:"https://www.kernel.org/doc/html/latest/driver-api/pps.html"},"Linux Kernel Documentation: PPS - Pulse Per Second"))))}b.isMDXComponent=!0}}]);